/* eslint-disable no-undefined */
/// <reference types="vitest" />
/// <reference types="vitest-dom" />

import { AItemContext } from '../../src/AItemContext';
import { useAItem } from '../../src/AItemProvider';
import { useCItemAdapter } from '../../src/contained/CItemAdapter';
import { CItemAdapterContext, CItemAdapterContextType } from '../../src/contained/CItemAdapterContext';
import { CItemContext, CItemContextType, useCItem } from '../../src/contained/CItemContext';
import { CItemLoad } from '../../src/contained/CItemLoad';
import { CacheMap } from '@fjell/cache';
import { ComKey, Item } from '@fjell/core';
import { render, waitFor } from '@testing-library/react';
import React, { useEffect, useState } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Mocked, vi } from 'vitest';

vi.mock('@/contained/CItemAdapter');
vi.mock('@/AItemProvider');

interface TestItem extends Item<'test', 'container'> {
  name: string;
}

describe('CItemLoad', () => {

  let key: ComKey<"test", "container">;
  let mockAdapter: Mocked<CItemAdapterContextType<TestItem, 'test', 'container'>>;
  let mockCacheMap: Mocked<CacheMap<TestItem, 'test', 'container'>>;
  let adapterContext: React.Context<CItemAdapterContextType<TestItem, 'test', 'container'> | undefined>;
  let parentContext: React.Context<AItemContext<Item<"container">, "container"> | undefined>;
  let testContext: React.Context<CItemContextType<TestItem, 'test', 'container'> | undefined>;
  let mockTestItem: TestItem;

  let TestItemLoad: React.FC<{ children: React.ReactNode; ik: ComKey<"test", "container"> | null }>;
  let TestItemRender: React.FC;

  beforeEach(() => {

    key = {
      kt: 'test', pk: '1-1-1-1-1',
      loc: [{ kt: 'container', lk: '2-2-2-2-2' }],
    } as ComKey<"test", "container">;

    mockCacheMap = {
      get: vi.fn(),
    } as unknown as Mocked<CacheMap<TestItem, 'test', 'container'>>;

    mockAdapter = {
      name: 'test',
      get: vi.fn(),
      action: vi.fn(),
      find: vi.fn(),
      cacheMap: mockCacheMap,
      pkTypes: ['test', 'container'],
      all: vi.fn(),
      one: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      remove: vi.fn(),
      allAction: vi.fn(),
      retrieve: vi.fn(),
      set: vi.fn(),
    } as Mocked<CItemAdapterContextType<TestItem, 'test', 'container'>>;

    const mockParentAdapter = {
      locations: [{ kt: 'container', lk: 'location1' }],
      item: { id: 'parent1', name: 'Parent Item' },
    };

    (useCItemAdapter as jest.Mock).mockReturnValue(mockAdapter);
    (useAItem as jest.Mock).mockReturnValue(mockParentAdapter);

    adapterContext = React.createContext<CItemAdapterContextType<TestItem, 'test', 'container'> | undefined>(undefined);
    parentContext = React.createContext<AItemContext<Item<"container">, "container"> | undefined>(undefined);
    testContext = React.createContext<CItemContextType<TestItem, 'test', 'container'> | undefined>(undefined);

    mockTestItem = {
      id: 'test-id',
      key,
      events: {
        created: { at: new Date() },
        updated: { at: new Date() },
        removed: { at: null },
      },
      deleted: false,
      name: 'Test Item',
    } as unknown as TestItem;

    TestItemLoad = (
      {
        children,
        ik,
      }: {
        children: React.ReactNode;
        ik: ComKey<"test", "container"> | null;
      }
    ) => {
      return CItemLoad<
        TestItem,
        "test",
        "container"
      >({
        name: 'test',
        parent: parentContext as AItemContext<Item<"container">, "container">,
        adapter: adapterContext as CItemAdapterContext<TestItem, 'test', 'container'>,
        context: testContext as CItemContext<TestItem, 'test', 'container'>,
        children,
        ik,
        contextName: 'test',
        parentContextName: 'container'
      });
    };

    TestItemRender = () => {
      const { item } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      return <div>{item?.name}</div>;
    };

  });

  it('should render children', () => {

    mockCacheMap.get.mockReturnValue(mockTestItem);

    const { getByText } = render(
      <TestItemLoad ik={key}>
        <TestItemRender />
      </TestItemLoad>
    );

    expect(getByText('Test Item')).toBeInTheDocument();
  });

  it('pass in a null ik', () => {

    const { queryByText } = render(
      <TestItemLoad ik={null}>
        <TestItemRender />
      </TestItemLoad>
    );

    expect(queryByText('Test Item')).not.toBeInTheDocument();
  });

  it('pass in an ik that is a PriKey', () => {
    expect(() => render(
      // @ts-ignore
      <TestItemLoad ik={{ kt: 'test', pk: '1-1-1-1-1' }}>
        <div>test</div>
      </TestItemLoad>
    )).toThrow('Key is not a ComKey');
  });

  it('test remove', async () => {
    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestRemove: React.FC = () => {
      const { item, remove } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [deleted, setDeleted] = useState(false);

      useEffect(() => {
        if( item ) {
          remove();
          setDeleted(true);
        }
      }, [item, remove]);

      return <div>{deleted ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <TestItemLoad ik={key}>
        <TestRemove />
      </TestItemLoad>
    );

    await waitFor(() => {
      expect(getByText('success')).toBeInTheDocument();
    });
  });

  it('test remove without a valid key', async () => {
    const invalidKey = {
      kt: 'test', pk: '1-1-1-1-1',
      loc: [{ kt: 'container', lk: 'null' }]
    } as ComKey<"test", "container">;

    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestRemove: React.FC = () => {
      const { key, remove } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [deleted, setDeleted] = useState(false);

      useEffect(() => {
        if( key ) {
          remove();
          setDeleted(true);
        }
      }, [key, remove]);

      return <div>{deleted ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <ErrorBoundary fallbackRender={() => <div>Error Thrown</div>}>
        <TestItemLoad ik={invalidKey}>
          <TestRemove />
        </TestItemLoad>
      </ErrorBoundary>
    );

    await waitFor(() => {
      expect(getByText('Error Thrown')).toBeInTheDocument();
    });
  });

  it('test update', async () => {
    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestUpdate: React.FC = () => {
      const { item, update } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [updated, setUpdated] = useState(false);

      useEffect(() => {
        if( item ) {
          update({ name: 'Updated Item' });
          setUpdated(true);
        }
      }, [item, update]);

      return <div>{updated ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <TestItemLoad ik={key}>
        <TestUpdate />
      </TestItemLoad>
    );

    await waitFor(() => {
      expect(getByText('success')).toBeInTheDocument();
    });
  });

  it('test update with no item', async () => {
    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestUpdate: React.FC = () => {
      const { item, update } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [updated, setUpdated] = useState(false);

      useEffect(() => {
        if( item ) {
          // @ts-ignore
          update(null);
          setUpdated(true);
        }
      }, [item, update]);

      return <div>{updated ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <ErrorBoundary fallbackRender={() => <div>Error Thrown</div>}>
        <TestItemLoad ik={key}>
          <TestUpdate />
        </TestItemLoad>
      </ErrorBoundary>
    );

    await waitFor(() => {
      expect(getByText('Error Thrown')).toBeInTheDocument();
    });
  });

  it('test update without a valid key', async () => {
    const invalidKey = {
      kt: 'test', pk: '1-1-1-1-1',
      loc: [{ kt: 'container', lk: 'null' }]
    } as ComKey<"test", "container">;

    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestUpdate: React.FC = () => {
      const { key, update } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [updated, setUpdated] = useState(false);

      useEffect(() => {
        if( key ) {
          update({ name: 'Updated Item' });
          setUpdated(true);
        }
      }, [key, update]);

      return <div>{updated ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <ErrorBoundary fallbackRender={() => <div>Error Thrown</div>}>
        <TestItemLoad ik={invalidKey}>
          <TestUpdate />
        </TestItemLoad>
      </ErrorBoundary>
    );

    await waitFor(() => {
      expect(getByText('Error Thrown')).toBeInTheDocument();
    });
  });

  it('test action', async () => {
    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestAction: React.FC = () => {
      const { item, action } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [actioned, setActioned] = useState(false);

      useEffect(() => {
        if( item ) {
          action('testAction');
          setActioned(true);
        }
      }, [item, action]);

      return <div>{actioned ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <TestItemLoad ik={key}>
        <TestAction />
      </TestItemLoad>
    );

    await waitFor(() => {
      expect(getByText('success')).toBeInTheDocument();
    });
  });

  it('test action without a valid key', async () => {
    const invalidKey = {
      kt: 'test', pk: '1-1-1-1-1',
      loc: [{ kt: 'container', lk: 'null' }]
    } as ComKey<"test", "container">;

    mockCacheMap.get.mockReturnValue(mockTestItem);

    const TestAction: React.FC = () => {
      const { key, action } = useCItem<TestItem, 'test', 'container'>(
        testContext as CItemContext<TestItem, 'test', 'container'>,
        'test'
      );
      const [actioned, setActioned] = useState(false);

      useEffect(() => {
        if( key ) {
          action('testAction');
          setActioned(true);
        }
      }, [key, action]);

      return <div>{actioned ? 'success' : 'failure'}</div>;
    }

    const { getByText } = render(
      <ErrorBoundary fallbackRender={() => <div>Error Thrown</div>}>
        <TestItemLoad ik={invalidKey}>
          <TestAction />
        </TestItemLoad>
      </ErrorBoundary>
    );

    await waitFor(() => {
      expect(getByText('Error Thrown')).toBeInTheDocument();
    });
  });
});
